from fastapi import FastAPI, Body, Form, Query
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from pydantic import BaseModel, Field
import firebase_admin
from firebase_admin import credentials, firestore
import uvicorn
import uuid
from typing import Optional
from app_utils import *


log = putlog("MainExecutor")

configFile = "config/app.setting.json"
configuration = readJson(configFile)

if not firebase_admin._apps:
    cred = credentials.Certificate(configuration["Secrets"]["Credentials"])
    # cred = credentials.Certificate(configuration["Secrets"]["Render"])
    firebase_admin.initialize_app(cred)

app = FastAPI()

# origins = ["http://localhost:3000"]
# origins = ["promptopedia-chi.vercel.app",
#            "promptopedia-8ol8drbua-varad-kulkarnis-projects.vercel.app",
#            "promptopedia-e7ek90zge-varad-kulkarnis-projects.vercel.app"]
origins = ["*"]

app.add_middleware(GZipMiddleware, minimum_size=512)
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# firestore_db = firestore.Client(credentials=cred)
firestore_db = firestore.client()

collection_name = configuration["Database"]["CollectionName"]


class Item(BaseModel):
    id: str = Field(default_factory=uuid.uuid4)
    prompt: str
    tags: list[str]  # List of strings for tags


@app.get("/posts")
async def getPosts():
    """
    The function `getPosts` retrieves all posts from the Firestore collection specified by
    `collection_name`.

    :return: The function returns a list of dictionaries containing details about all retrieved
             posts. Each dictionary represents a single post and includes the following fields:

             * id (str): A unique identifier for the post generated by Firestore.
             * name (str): The user name associated with the post (if provided).
             * email (str): The email address associated with the post.
             * photo (str): A URL to an image associated with the post (if provided).
             * prompt (str): The text content of the post.
             * tags (list): A list of tags associated with the post.

             If there is an error while fetching the posts, the function returns a dictionary with
             a single key:

             * message (str): An error message indicating "Error in fetching the posts. Please try again later."
    """
    try:
        items = []
        docs = firestore_db.collection(collection_name).stream()
        for doc in docs:
            items.append({**doc.to_dict(), "id": doc.id})
        return items
    except Exception as e:
        print(f"Error in fetching the posts: {e}")
        return {"message": "Error in fetching the posts. Please try again later."}


@app.post("/posts")
async def createPost(prompt: str = Form(...), tags: str = Form(...), name: str = Form(...), email: str = Form(...), photo: str = Form(...)):
    """ 
    The function `createPost` creates a new post in the Firestore collection specified by
    `collection_name`. It takes various user-provided details about the post and stores them
    along with a generated unique identifier.

    :param prompt: The `prompt` parameter is a required string field containing the text content
                   of the post.
    :type prompt: Annotated[str, Form(...)]

    :param tags: The `tags` parameter is an optional string field that allows users to categorize
                 the post with comma-separated tags (e.g., "funny,cat"). The function splits the
                 provided string on commas to create a list of tags.
    :type tags: Optional[Annotated[str, Form(...)]]

    :param name: The `name` parameter is an optional string field for the user's name.
    :type name: Optional[Annotated[str, Form(...)]]

    :param email: The `email` parameter is an optional string field for the user's email address.
    :type email: Optional[Annotated[str, Form(...)]]

    :param photo: The `photo` parameter is an optional string field containing a URL to an image
                  associated with the post.
    :type photo: Optional[Annotated[str, Form(...)]]

    :return: The function returns a dictionary with details about the created post. In case of
             errors, it returns a dictionary with an error message.
    """
    try:
        doc_ref = firestore_db.collection(collection_name).document()
        item = {
            "id": doc_ref.id,
            "name": name,
            "email": email,
            "photo": photo,
            "prompt": prompt,
            "tags": tags.split(','),  # Split comma-separated tags
        }
        doc_ref.set(item)
        return item
    except Exception as e:
        print(f"Error in creating post:{e}")
        return {"message": "Error in creating post. Please try again later."}


@app.get("/get_items_by_email/")
async def getItemsByEmail(email: str = Query(..., description="Email address to filter posts")):
    """
    The function `getItemsByEmail` retrieves all posts from the Firestore collection specified by
    `collection_name` that belong to a particular user identified by their email address.

    :param email: The `email` parameter is a required string field representing the email address
                   used to filter the posts. Users can access their own posts or potentially posts
                   from other users depending on authorization rules.
    :type email: Annotated[str, Query(..., description="Email address to filter posts")]

    :return: The function returns a list of dictionaries containing details about the retrieved
             posts. 
"""
    try:
        doc_ref = firestore_db.collection(collection_name).where(
            "email", "==", email)  # Using query operator
        docs = doc_ref.get()  # Fetch multiple documents

        if docs:
            posts = [doc.to_dict() for doc in docs]
            return posts
        else:
            return {"error": "Item not found"}
    except Exception as e:
        print(f"Error in fetching posts by email: {e}")
        return {"message": "Error in fetching posts by email. Please try again later."}


@app.get("/get_post_by_id/")
async def getPostById(postId: str = Query(..., description="Post Id to filter posts")):
    """
    The function `getPostById` retrieves a specific post from the Firestore collection specified by
    `collection_name`. The post is identified by its unique identifier provided in the URL.

    :param postId: The `postId` parameter is a required string field representing the unique
                   identifier of the post to be retrieved. This ID is typically generated by
                   Firestore when a new post is created.
    :type postId: Annotated[str, Query(..., description="Post Id to filter posts")]

    :return: The function returns a dictionary containing details about the retrieved post.
    """
    try:
        doc_ref = firestore_db.collection(collection_name).where(
            "id", "==", postId)  # Using query operator
        docs = doc_ref.get()  # Fetch multiple documents
        if docs:
            posts = [doc.to_dict() for doc in docs]
            return posts
        else:
            return {"error": "Item not found"}
    except Exception as e:
        print(f"Error in fetching posts by id: {e}")
        return {"message": "Error in fetching posts. Please try again later."}


@app.put("/update_post")
async def updatePost(postId: str = Query(..., description="Edit post by id"), updatedData: Item = Body(...)):
    """
    The function `updatePost` allows editing an existing post in the Firestore collection specified by
    `collection_name`. The post is identified by its unique identifier provided in the URL. Users can
    only update specific fields (`prompt` and `tags` in this case) of the post.

    :param postId: The `postId` parameter is a required string field representing the unique
                   identifier of the post to be edited. This ID is typically generated by Firestore
                   when a new post is created.
    :type postId: Annotated[str, Query(..., description="Edit post by id")]

    :param updatedData: The `updatedData` parameter is a required object containing the specific
                        fields the user wants to modify. Currently, the function allows updates to
                        the `prompt` (text content) and `tags` (list of strings) of the post.
    :type updatedData: Annotated[Item, Body(...)]

    :return: The function returns a dictionary with a message upon successful update
    """
    try:
        updatedData = {"prompt": updatedData.prompt, "tags": updatedData.tags}
        doc_ref = firestore_db.collection(collection_name).document(postId)
        doc_ref.update(updatedData)
        return {"message": "Item updated successfully"}
    except Exception as e:
        print(f"Error updating post: {e}")
        return {"message": "Error in updating the post. Please try again later."}


@app.delete("/delete_post/")
async def deletePost(postId: str = Query(..., description="Delete post by id")):
    """
    The function `deletePost` removes a post from the Firestore collection specified by
    `collection_name`. The post is identified by its unique identifier provided in the URL.

    :param postId: The `postId` parameter is a required string field representing the unique
                   identifier of the post to be deleted. This ID is typically generated by Firestore
                   when a new post is created.
    :type postId: Annotated[str, Query(..., description="Delete post by id")]

    :return: The function returns a dictionary with a message upon successful deletion:

             * message (str): "Post deleted successfully"

             In case of errors during deletion, the function returns a dictionary with an error message:

             * message (str): "Error in deleting the post. Please try again later."
    """
    try:
        doc_ref = firestore_db.collection(collection_name).document(postId)
        doc_ref.delete()
        return {"message": "Post deleted successfully"}
    except Exception as e:
        print(f"Error in deleting the post: {e}")
        return {"message": "Error in deleting the post. Please try again later."}

if __name__ == "__main__":
    uvicorn.run(
        "main:app", host=configuration["App"]["Host"], port=configuration["App"]["Port"])
